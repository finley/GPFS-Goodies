#!/usr/bin/perl -w

#
#   The idea:
#
#       Once a GPFS filesystem has been created, tune the block device
#       settings underneath it automatically, on a per-NSD basis:
#       
#       Create:
#       - one udev rule file etc/udev/rules.d/70-ibm-storage.rules
#       - one udev rule per device
#       - push that one rule file out across all nodes
#
#       Calculate certain values based on:
#       - number of NSD servers serving each NSD
#       - relevant FS parameters: i.e.: block size (mmlsfs -B)
#       

#
#   2013.11.10 Brian Elliott Finley <bfinley@us.ibm.com>
#   - created
#   2013.11.18 Brian Elliott Finley <bfinley@us.ibm.com>
#   - add initial default tuning settings
#

use strict;

my $cmd;
my %filesystems;
my %mpath_by_nsd;
my %server_by_mpath;
my %nsd_server_list;
my %filesystems_by_nsd;
my %blocksize_by_filesystem;

my $debug;
$debug = 'on';

#
# Info Gather Pass 1
#
$cmd = 'mmlsnsd 2>&1';
print ">> Command: $cmd\n" if(defined $debug);
open(INPUT,"$cmd|") or die("Couldn't run $cmd for input.");
while(<INPUT>) {
    #
    #   Sample input:
    #
    #    File system   Disk name    NSD servers                                    
    #   ---------------------------------------------------------------------------
    #    fs_1m         nsd_0        x36n09,x36n10            
    #    fs_1m         nsd_1        x36n10,x36n11            
    #    fs_1m         nsd_2        x36n11,x36n12            
    #    fs_1m         nsd_3        x36n12,x36n09            
    #    fs_1m         nsd_4        x36n09,x36n10            
    #    fs_1m         nsd_5        x36n10,x36n11            
    #    fs_1m         nsd_6        x36n10,x36n11            
    #    fs_1m         nsd_7        x36n11,x36n12            
    #    fs_1m         nsd_8        x36n12,x36n09            
    #    fs_1m         nsd_9        x36n09,x36n10            
    #    fs_1m         nsd_10       x36n10,x36n11            
    #    fs_1m         nsd_11       x36n11,x36n12            
    #    fs_1m         nsd_12       x36n11,x36n12            
    #    fs_1m         nsd_13       x36n12,x36n09            
    #    fs_1m         nsd_14       x36n09,x36n10            
    #    fs_1m         nsd_15       x36n10,x36n11            
    #    fs_1m         nsd_16       x36n11,x36n12            
    #    fs_1m         nsd_17       x36n12,x36n09            
    #    fs_1m         nsd_18       x36n12,x36n09            
    #    fs_1m         nsd_19       x36n09,x36n10            
    #    fs_1m         nsd_20       x36n10,x36n11            
    #    fs_1m         nsd_21       x36n11,x36n12            
    #    fs_1m         nsd_22       x36n12,x36n09            
    #    fs_1m         nsd_23       x36n09,x36n10            
    #    fs_1m         nsd_24       x36n09,x36n10            
    #    fs_1m         nsd_25       x36n10,x36n11            
    #    fs_1m         nsd_26       x36n11,x36n12            
    #    fs_1m         nsd_27       x36n12,x36n09            
    #    fs_1m         nsd_28       x36n09,x36n10            
    #    fs_1m         nsd_29       x36n10,x36n11        
    #
    print ">> $_" if(defined $debug);
    if(m/^\s+(\S+)\s+(\S+)\s+(\S+)\s*$/) {

        my $fs      = $1;
        my $nsd     = $2;
        my $servers = $3;

        $filesystems{$fs} = 1;
        $filesystems_by_nsd{$nsd} = $fs;

        foreach my $server ( split(/,/, $servers) ) {
            $nsd_server_list{$server} = 1;
        }
    }
}
close(INPUT);


#
# Info Gather Pass 2
#
$cmd = 'mmlsnsd -m 2>&1';
print ">> Command: $cmd\n" if(defined $debug);
open(INPUT,"$cmd|") or die("Couldn't run $cmd for input.");
while(<INPUT>) {
    #	
    #   Sample input:
    #
    #	[root@x36n10 bef]# mmlsnsd -m
    #	
    #	 Disk name    NSD volume ID      Device         Node name                Remarks       
    #	---------------------------------------------------------------------------------------
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n09                   server node
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n10                   server node
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n11                   
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n12                   
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n09                   
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n10                   server node
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n11                   server node
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n12                   
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n09                   
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n10                   server node
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n11                   server node
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n12                   
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n09                   
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n10                   
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n11                   server node
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n12                   server node
    #	 nsd_12       AC10000B527FEC39   /dev/mapper/dcs3860a_lun12 x36n09                   
    #	 nsd_12       AC10000B527FEC39   /dev/mapper/dcs3860a_lun12 x36n10                   
    #	[snip]
    #
    print ">> $_" if(defined $debug);
    if(m/^\s+(\S+)\s+\S+\s+(\S+)\s+(\S+)\s.*server node$/) {

        my $nsd     = $1;
        my $mpath   = $2;
        my $server  = $3;

        if( ! defined $mpath_by_nsd{$nsd} and $mpath =~ m#^/dev/#) {
            $mpath_by_nsd{$nsd}      = $mpath;
            $server_by_mpath{$mpath} = $server;
        }
    }
}
close(INPUT);

#
# Info Gather Pass 3
#
foreach my $fs (keys %filesystems) {
    my $cmd = "mmlsfs $fs 2>&1";
    print ">> Command: $cmd\n" if(defined $debug);
    open(INPUT,"$cmd|") or die("Can't run $cmd for input");
    while(<INPUT>) {
        #
        # Sample input:
        #
        # [root@x36n01 bef]# ./tune_block_device_settings 
        # flag                value                    description
        # ------------------- ------------------------ -----------------------------------
        #  -f                 32768                    Minimum fragment size in bytes
        #  -i                 512                      Inode size in bytes
        #  -I                 32768                    Indirect block size in bytes
        #  -m                 1                        Default number of metadata replicas
        #  -M                 2                        Maximum number of metadata replicas
        #  -r                 1                        Default number of data replicas
        #  -R                 2                        Maximum number of data replicas
        #  -j                 scatter                  Block allocation type
        #  -D                 nfs4                     File locking semantics in effect
        #  -k                 all                      ACL semantics in effect
        #  -n                 32                       Estimated number of nodes that will mount file system
        #  -B                 1048576                  Block size
        #  -Q                 none                     Quotas enforced
        #                     none                     Default quotas enabled
        #  --filesetdf        No                       Fileset df enabled?
        #  -V                 13.23 (3.5.0.7)          File system version
        #  --create-time      Sun Nov 10 17:20:44 2013 File system creation time
        #  -u                 Yes                      Support for large LUNs?
        #  -z                 No                       Is DMAPI enabled?
        #  -L                 4194304                  Logfile size
        #  -E                 Yes                      Exact mtime mount option
        #  -S                 No                       Suppress atime mount option
        #  -K                 whenpossible             Strict replica allocation option
        #  --fastea           Yes                      Fast external attributes enabled?
        #  --inode-limit      134217728                Maximum number of inodes
        #  -P                 system                   Disk storage pools in file system
        #  -d                 nsd_0;nsd_1;nsd_2;nsd_3;nsd_4;nsd_5;nsd_6;nsd_7;nsd_8;nsd_9;nsd_10;nsd_11;nsd_12;nsd_13;nsd_14;nsd_15;nsd_16;nsd_17;nsd_18;nsd_19;nsd_20;nsd_21;nsd_22;nsd_23;nsd_24;
        #  -d                 nsd_25;nsd_26;nsd_27;nsd_28;nsd_29  Disks in file system
        #  --perfileset-quota no                       Per-fileset quota enforcement
        #  -A                 yes                      Automatic mount option
        #  -o                 none                     Additional mount options
        #  -T                 /fs_1m                   Default mount point
        #  --mount-priority   0                        Mount priority
        # 
        print ">> $_" if(defined $debug);
        if(m/^\s+-B\s+(\d+)\s+/) {
            my $blocksize = $1;
            $blocksize_by_filesystem{$fs} = $blocksize;
        }
    }
    close(INPUT);
}

my $file = get_tmp_file();
open(FILE,">$file") or die("Couldn't open $file for writing");
foreach my $nsd (keys %filesystems_by_nsd) {

    my $fs = $filesystems_by_nsd{$nsd};
    my $bs = $blocksize_by_filesystem{$fs};
    my $mpath = $mpath_by_nsd{$nsd};
    my $server = $server_by_mpath{$mpath};

    my $max_sectors_kb = 512;
    my $read_ahead_kb  = 512;
    my $nr_requests    = 512;
    my $queue_depth    = calculate_queue_depth();
    my $elevator       = 'noop';

    if( defined $mpath ) { 
        my $scsi_id = get_scsi_id( $server, $mpath );
        if(defined $scsi_id) {

            print FILE qq(#\n);
            print FILE qq(# NSD: $nsd  PATH: $mpath\n);

            print FILE q(SUBSYSTEM=="block", SUBSYSTEMS=="scsi", PROGRAM=="/lib/udev/scsi_id -g -u -d /dev/%k", RESULT==") . $scsi_id . q(", RUN+="/bin/sh -c ');
            print FILE q(/bin/echo ) . $max_sectors_kb . q( > /sys/block/%k/queue/max_sectors_kb; );
            print FILE q(/bin/echo ) . $read_ahead_kb  . q( > /sys/block/%k/queue/read_ahead_kb; );
            print FILE q(/bin/echo ) . $nr_requests    . q( > /sys/block/%k/queue/nr_requests; );
            print FILE q(/bin/echo ) . $queue_depth    . q( > /sys/block/%k/device/queue_depth; );
            print FILE q(/bin/echo ) . $elevator       . q( > /sys/block/%k/queue/scheduler; );
            print FILE qq('"\n\n);
            
        } else {
            print "$nsd -- Couldn't not retrieve the scsi_id from $server:$mpath.\n";
            exit 1;
        }

    } else {
        print "$nsd -- ERROR No path to device found for this NSD.\n";
        print "  Please make sure that all devices, and ideally all NSD servers are fully operational.\n";
        print "\n";
        exit 1;
    }

}
close(FILE);

print "Your new rules can be found here: $file\n";
distribute_rule($file);

exit 0;


########################################################################
#
#   BEGIN Subroutines
#
sub get_tmp_file {

    my $cmd = 'mktemp /tmp/gpfs_goodies.XXXXXXXXXX';

    my $file;

    open(INPUT,"$cmd|") or die("Couldn't run $cmd for input");
    while(<INPUT>) {
        if( m#^(/tmp/gpfs_goodies.*)# ) {
            $file = $1;
        }
    }
    close(INPUT);

    return $file;
}

sub distribute_rule {

    my $file = shift;

    foreach my $server (sort keys %nsd_server_list) {
        my $cmd = "scp $file $server:/etc/udev/rules.d/70-ibm-storage.rules";
        print ">> Command: $cmd\n" if(defined $debug);
        #!system($cmd) or die("FAILED: $cmd\n");
    }

    return 1;
}

sub udev_reread {

    #
    #   RHEL6 and friends, Ubuntu 12.10 and later:
    #       udevadm trigger --verbose --subsystem-match=block
    #
    #   RHEL5 and friends:
    #       udevcontrol reload_rules
    #

    return undef;
}

sub get_scsi_id {
    
    my $server  = shift;
    my $mpath   = shift;

    my $scsi_id;
    
    my $cmd = "ssh $server /lib/udev/scsi_id -g -u -d $mpath";
    print ">> Command: $cmd\n" if(defined $debug);
    open(INPUT,"$cmd|") or die("Couldn't run $cmd for input.");
    while(<INPUT>) {
        # 
        #   Example Input -- this is what we expect the response to normally
        #   look like, but as long as it's a unique string, we don't really 
        #   care.  We are currently making the assumption (XXX) that it will
        #   start with a '36' and will have no spaces.  This can be made more 
        #   general later if necessary.
        # 
        #   360080e50002934b80000403b5283dbe6
        #   360080e50002937b800003f6b5283dbf5
        #   360080e50002937b800003f8f5283dc3f
        # 
        if( m/^(36\S+)/ ) {
            $scsi_id = $1;
            last;
        }
    }
    close(INPUT);

    if(defined $scsi_id) {
        return $scsi_id;
    } else {
        return undef;
    }
}

sub calculate_queue_depth {

    #
    # queue_depth:  Ideal size can be determined by this formula:
    #   
    #   For each storage controller, we use a modern assumption that it has
    #   a 4096 total queue depth for receiving requests from all nodes that
    #   connect to it.  Therefore:
    #
    #       4096 / ($storage_nodes * $luns) => Target_queue_depth
    #
    #   So, for 4 storage servers, with 30 LUNs off of a single controller,
    #   we get:
    #
    #       4096 / (4 * 30) = 34.13
    #
    #   Let's round down with a binary factor, just because:
    #
    #       34.13 / 8 = 4 (and change, but we'll drop the change)
    #
    #       4 * 8 = 32
    #
    #   And so "32" is the ideal queue_depth in this case.  See how easy
    #   that was? ;-)
    #

    return 32;

}

#
#   END Subroutines
#
########################################################################

#   :set tw=0 ts=4 ai et   
