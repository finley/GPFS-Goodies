#!/usr/bin/perl -w

#
#   "tune_block_device_settings"
#
#   How it works:
#
#       This command should be run from one of your GPFS cluster
#       connected nodes after creating your GPFS file systems.  It will
#       detect a number of things in your GPFS cluster environment, and
#       make calculations based on best practices to create optimized
#       block device tuning settings in the form of udev rules.
#
#       Some of the data it uses to make it's calculations include:
#
#           - Storage controller models
#           - Storage controller settings, such as cache mirroring
#             enabled/disabled
#           - Number of storage servers connected to each controller
#           - GPFS file system block sizes
#
#       It will create a single udev rule file
#       (/etc/udev/rules.d/99-ibm-storage.rules), with one rule per
#       device and give you the option of a) deploying the rules to your
#       storage servers for you, and b) hot-activating the settings via
#       udev.
#

#
#   2013.11.10 Brian Elliott Finley <bfinley@us.ibm.com>
#   - created
#   2013.11.18 Brian Elliott Finley <bfinley@us.ibm.com>
#   - add initial default tuning settings
#   2014.01.03 Brian Elliott Finley <bfinley@us.ibm.com>
#   - minor refinements after testing on Ray Paden's test cluster
#

use strict;
use Getopt::Long;
use File::Basename;

my $progname = basename($0);
my $version_number = '20.7.22';
my $udev_rules_file = '/etc/udev/rules.d/99-ibm-storage.rules';

our $ERROR = 0;

GetOptions(
    "help"              => \my $help,
    "version"           => \my $version,
    "deploy"            => \my $deploy,
    "disks-per-array=i" => \my $disks_per_array,
    "test-run"          => \my $test_run,
    "verbose|v"         => \my $debug,
    "out-file=s"        => \my $out_file,
) or usage() and exit(1);

if ( defined $help ) {
    usage();
    exit 0;
} 
elsif ( defined $version ) {
    version();
    exit 0;
}

if( (! defined $deploy and ! defined $test_run ) or ( defined $deploy and defined $test_run ) ) {
    usage();
    print qq(\n-->  Try either "--deploy" or "--test-run"\n\n);
    exit 0;
}

if( ! defined $disks_per_array ) {
    usage();
    print qq(\n-->  Try "--disks-per-array NN"\n\n);
    exit 0;
}

if( ! defined $out_file ) {
    $out_file = get_tmp_file();
}

unless ( user_is_root() ) {
    usage();
    print qq(\n-->  Please run as root\n\n);
    exit 1;
}

unless ( -e "/usr/lpp/mmfs/bin/mmlsnsd" and -e "/usr/lpp/mmfs/bin/mmlsfs" ) {
    usage();
    print qq(\n-->  GPFS doesn't appear to be installed on this machine\n\n);
    exit 1;
}


my $cmd;
my %filesystems;
my %mpath_by_nsd;
my %server_by_mpath;
my %nsd_server_list;
my %filesystems_by_nsd;
my %blocksize_by_filesystem;
my %block_allocation_type_by_filesystem;

#
# Info Gather Pass 1
#
$cmd = '/usr/lpp/mmfs/bin/mmlsnsd 2>&1';
print ">> Command: $cmd\n" if(defined $debug);
open(INPUT,"$cmd|") or die("Couldn't run $cmd for input.");
while(<INPUT>) {
    #
    #   Sample input:
    #
    #    File system   Disk name    NSD servers                                    
    #   ---------------------------------------------------------------------------
    #    fs_1m         nsd_0        x36n09,x36n10            
    #    fs_1m         nsd_1        x36n10,x36n11            
    #    fs_1m         nsd_2        x36n11,x36n12            
    #    fs_1m         nsd_3        x36n12,x36n09            
    #    fs_1m         nsd_4        x36n09,x36n10            
    #    fs_1m         nsd_5        x36n10,x36n11            
    #    fs_1m         nsd_6        x36n10,x36n11            
    #    fs_1m         nsd_7        x36n11,x36n12            
    #    fs_1m         nsd_8        x36n12,x36n09            
    #    fs_1m         nsd_9        x36n09,x36n10            
    #    fs_1m         nsd_10       x36n10,x36n11            
    #    fs_1m         nsd_11       x36n11,x36n12            
    #    fs_1m         nsd_12       x36n11,x36n12            
    #    fs_1m         nsd_13       x36n12,x36n09            
    #    fs_1m         nsd_14       x36n09,x36n10            
    #    fs_1m         nsd_15       x36n10,x36n11            
    #    fs_1m         nsd_16       x36n11,x36n12            
    #    fs_1m         nsd_17       x36n12,x36n09            
    #    fs_1m         nsd_18       x36n12,x36n09            
    #    fs_1m         nsd_19       x36n09,x36n10            
    #    fs_1m         nsd_20       x36n10,x36n11            
    #    fs_1m         nsd_21       x36n11,x36n12            
    #    fs_1m         nsd_22       x36n12,x36n09            
    #    fs_1m         nsd_23       x36n09,x36n10            
    #    fs_1m         nsd_24       x36n09,x36n10            
    #    fs_1m         nsd_25       x36n10,x36n11            
    #    fs_1m         nsd_26       x36n11,x36n12            
    #    fs_1m         nsd_27       x36n12,x36n09            
    #    fs_1m         nsd_28       x36n09,x36n10            
    #    fs_1m         nsd_29       x36n10,x36n11        
    #
    print ">> $_" if(defined $debug);
    if(m/^\s+(\S+)\s+(\S+)\s+(\S+)\s*$/) {

        my $fs      = $1;
        my $nsd     = $2;
        my $servers = $3;

        $filesystems{$fs} = 1;
        $filesystems_by_nsd{$nsd} = $fs;

        foreach my $server ( split(/,/, $servers) ) {
            $nsd_server_list{$server} = 1;
        }
    }
}
close(INPUT);


#
# Info Gather Pass 2
#
$cmd = '/usr/lpp/mmfs/bin/mmlsnsd -m 2>&1';
print ">> Command: $cmd\n" if(defined $debug);
open(INPUT,"$cmd|") or die("Couldn't run $cmd for input.");
while(<INPUT>) {
    #	
    #   Sample input:
    #
    #	[root@x36n10 bef]# mmlsnsd -m
    #	
    #	 Disk name    NSD volume ID      Device         Node name                Remarks       
    #	---------------------------------------------------------------------------------------
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n09                   server node
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n10                   server node
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n11                   
    #	 nsd_0        AC100009527FEBFE   /dev/mapper/dcs3860a_lun0 x36n12                   
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n09                   
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n10                   server node
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n11                   server node
    #	 nsd_1        AC10000A527FEC03   /dev/mapper/dcs3860b_lun1 x36n12                   
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n09                   
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n10                   server node
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n11                   server node
    #	 nsd_10       AC10000A527FEC30   /dev/mapper/dcs3860a_lun11 x36n12                   
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n09                   
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n10                   
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n11                   server node
    #	 nsd_11       AC10000B527FEC34   /dev/mapper/dcs3860b_lun10 x36n12                   server node
    #	 nsd_12       AC10000B527FEC39   /dev/mapper/dcs3860a_lun12 x36n09                   
    #	 nsd_12       AC10000B527FEC39   /dev/mapper/dcs3860a_lun12 x36n10                   
    #	[snip]
    #
    print ">> $_" if(defined $debug);
    if(m/^\s+(\S+)\s+\S+\s+(\S+)\s+(\S+)\s.*server node$/) {

        my $nsd     = $1;
        my $mpath   = $2;
        my $server  = $3;

        if( ! defined $mpath_by_nsd{$nsd} and $mpath =~ m#^/dev/#) {
            $mpath_by_nsd{$nsd}      = $mpath;
            $server_by_mpath{$mpath} = $server;
        }
    }
}
close(INPUT);

#
# Info Gather Pass 3
#
foreach my $fs (keys %filesystems) {
    my $cmd = "/usr/lpp/mmfs/bin/mmlsfs $fs 2>&1";
    print ">> Command: $cmd\n" if(defined $debug);
    open(INPUT,"$cmd|") or die("Can't run $cmd for input");
    while(<INPUT>) {
        #
        # Sample input:
        #
        # [root@x36n01 bef]# ./tune_block_device_settings 
        # flag                value                    description
        # ------------------- ------------------------ -----------------------------------
        #  -f                 32768                    Minimum fragment size in bytes
        #  -i                 512                      Inode size in bytes
        #  -I                 32768                    Indirect block size in bytes
        #  -m                 1                        Default number of metadata replicas
        #  -M                 2                        Maximum number of metadata replicas
        #  -r                 1                        Default number of data replicas
        #  -R                 2                        Maximum number of data replicas
        #  -j                 scatter                  Block allocation type
        #  -D                 nfs4                     File locking semantics in effect
        #  -k                 all                      ACL semantics in effect
        #  -n                 32                       Estimated number of nodes that will mount file system
        #  -B                 1048576                  Block size
        #  -Q                 none                     Quotas enforced
        #                     none                     Default quotas enabled
        #  --filesetdf        No                       Fileset df enabled?
        #  -V                 13.23 (3.5.0.7)          File system version
        #  --create-time      Sun Nov 10 17:20:44 2013 File system creation time
        #  -u                 Yes                      Support for large LUNs?
        #  -z                 No                       Is DMAPI enabled?
        #  -L                 4194304                  Logfile size
        #  -E                 Yes                      Exact mtime mount option
        #  -S                 No                       Suppress atime mount option
        #  -K                 whenpossible             Strict replica allocation option
        #  --fastea           Yes                      Fast external attributes enabled?
        #  --inode-limit      134217728                Maximum number of inodes
        #  -P                 system                   Disk storage pools in file system
        #  -d                 nsd_0;nsd_1;nsd_2;nsd_3;nsd_4;nsd_5;nsd_6;nsd_7;nsd_8;nsd_9;nsd_10;nsd_11;nsd_12;nsd_13;nsd_14;nsd_15;nsd_16;nsd_17;nsd_18;nsd_19;nsd_20;nsd_21;nsd_22;nsd_23;nsd_24;
        #  -d                 nsd_25;nsd_26;nsd_27;nsd_28;nsd_29  Disks in file system
        #  --perfileset-quota no                       Per-fileset quota enforcement
        #  -A                 yes                      Automatic mount option
        #  -o                 none                     Additional mount options
        #  -T                 /fs_1m                   Default mount point
        #  --mount-priority   0                        Mount priority
        # 
        print ">> $_" if(defined $debug);
        if(m/^\s+-B\s+(\d+)\s+/) {
            #  -B                 1048576                  Block size
            my $blocksize = $1;
            $blocksize_by_filesystem{$fs} = $blocksize;
        } elsif(m/^\s+-j\s+(scatter)\s+/) {
            #  -j                 scatter                  Block allocation type
            my $block_allocation_type = $1;
            $block_allocation_type_by_filesystem{$fs} = $block_allocation_type;
        }
    }
    close(INPUT);
}

my $file = $out_file;
open(FILE,">$file") or die("Couldn't open $file for writing");
foreach my $nsd (keys %filesystems_by_nsd) {

    my $fs = $filesystems_by_nsd{$nsd};
    my $bs = $blocksize_by_filesystem{$fs};
    my $block_allocation_type = $block_allocation_type_by_filesystem{$fs};

    my $mpath;
    my $server;
    if( defined $mpath_by_nsd{$nsd} ) {

        $mpath = $mpath_by_nsd{$nsd};
        $server = $server_by_mpath{$mpath};

        my $max_sectors_kb = calculate_max_sectors_kb($bs);
        my $read_ahead_kb  = calculate_read_ahead_kb($block_allocation_type, $max_sectors_kb);
        my $nr_requests    = calculate_nr_requests($disks_per_array);
        my $queue_depth    = calculate_queue_depth($disks_per_array);
        my $elevator       = 'noop';

        my $scsi_id = get_scsi_id( $server, $mpath );
        if(defined $scsi_id) {

            print FILE qq(#\n);
            print FILE qq(# NSD: $nsd  PATH: $mpath\n);
            print FILE qq(#\n);
            print FILE qq(#  Individual Devices\n);
            print FILE q(SUBSYSTEM=="block", SUBSYSTEMS=="scsi", PROGRAM=="/lib/udev/scsi_id -g -u -d /dev/%k", RESULT==") . $scsi_id . q(", RUN+="/bin/sh -c ');
            print FILE q(/bin/echo ) . $max_sectors_kb . q( > /sys/block/%k/queue/max_sectors_kb; );
            print FILE q(/bin/echo ) . $read_ahead_kb  . q( > /sys/block/%k/queue/read_ahead_kb; );
            print FILE q(/bin/echo ) . $nr_requests    . q( > /sys/block/%k/queue/nr_requests; );
            print FILE q(/bin/echo ) . $queue_depth    . q( > /sys/block/%k/device/queue_depth; );
            print FILE q(/bin/echo ) . $elevator       . q( > /sys/block/%k/queue/scheduler; );
            print FILE qq('"\n);
            print FILE qq(#\n);
            print FILE qq(#  Multipathed device\n);
            print FILE q(SUBSYSTEM=="block", KERNEL=="dm-*", PROGRAM=="/lib/udev/scsi_id -g -u -d /dev/%k", RESULT==") . $scsi_id . q(", RUN+="/bin/sh -c ');
            print FILE q(/bin/echo ) . $max_sectors_kb . q( > /sys/block/%k/queue/max_sectors_kb; );
            print FILE q(/bin/echo ) . $read_ahead_kb  . q( > /sys/block/%k/queue/read_ahead_kb; );
            print FILE q(/bin/echo ) . $nr_requests    . q( > /sys/block/%k/queue/nr_requests; );
            print FILE q(/bin/echo ) . $queue_depth    . q( > /sys/block/%k/device/queue_depth; );
            print FILE q(/bin/echo ) . $elevator       . q( > /sys/block/%k/queue/scheduler; );
            print FILE qq('"\n\n);
            
        } else {
            print "$nsd -- Couldn't not retrieve the scsi_id from $server:$mpath.\n";
            $ERROR++;
        }

    } else {
        print "$nsd -- ERROR No path to device found for this NSD.\n";
        $ERROR++;
    }

}
close(FILE);

if($ERROR == 0) {
    print "Your new rules can be found here:\n\n  $out_file\n\n";

    if(defined $deploy) {
        distribute_rule($out_file);
        udev_reread();
    } else {
        print "\n";
        print "Not deploying.  You might want to try --deploy.\n";
        print "\n";
        print "See $progname --help for details.\n";
        print "\n";
    }

} else {
    print "\n";
    print "  ERROR: Please make sure that all devices, and ideally all\n";
    print "         NSD servers are fully operational, then try again.\n";
    print "\n";
    print "         Try 'mmlsnsd -m' to verify.\n";
    print "\n";
    exit 1;
}

exit 0;


########################################################################
#
#   BEGIN Subroutines
#
sub get_tmp_file {

    my $cmd = "mktemp /tmp/$progname.XXXXXXXXXX";

    my $file;

    open(INPUT,"$cmd|") or die("Couldn't run $cmd for input");
    while(<INPUT>) {
        if( m#^(/tmp/$progname.*)# ) {
            $file = $1;
        }
    }
    close(INPUT);

    print ">> get_tmp_file => $file\n" if(defined $debug);
    return $file;
}

sub distribute_rule {

    my $file = shift;

    foreach my $server (sort keys %nsd_server_list) {
        my $cmd = "scp -q $file $server:$udev_rules_file";
        print "Deploying to $server as $udev_rules_file\n";
        print ">> Command: $cmd\n" if(defined $debug);
        !system($cmd) or die("FAILED: $cmd\n");
    }

    return 1;
}

sub udev_reread {

    #
    #   RHEL6 and friends, Ubuntu 12.10 and later:
    #       udevadm trigger --verbose --subsystem-match=block
    #       which udevadm >/dev/null 2>&1 && udevadm trigger --verbose --subsystem-match=block
    #
    #   RHEL5 and friends:
    #       udevcontrol reload_rules
    #
    foreach my $server (sort keys %nsd_server_list) {
        my $cmd = qq(ssh $server 'which udevadm >/dev/null 2>&1  &&  udevadm trigger --subsystem-match=block  ||  udevcontrol reload_rules');
        print ">> Command: $cmd\n" if(defined $debug);
        !system($cmd) or die("FAILED: $cmd\n");
    }

    return 1;
}

sub get_scsi_id {
    
    my $server  = shift;
    my $mpath   = shift;

    my $scsi_id;
    
    my $cmd = "ssh $server /lib/udev/scsi_id -g -u -d $mpath";
    print ">> Command: $cmd\n" if(defined $debug);
    open(INPUT,"$cmd|") or die("Couldn't run $cmd for input.");
    while(<INPUT>) {
        # 
        #   Example Input -- this is what we expect the response to normally
        #   look like, but as long as it's a unique string, we don't really 
        #   care.  We are currently making the assumption (XXX) that it will
        #   start with a '36' and will have no spaces.  This can be made more 
        #   general later if necessary.
        # 
        #   360080e50002934b80000403b5283dbe6
        #   360080e50002937b800003f6b5283dbf5
        #   360080e50002937b800003f8f5283dc3f
        # 
        if( m/^(36\S+)/ ) {
            $scsi_id = $1;
            last;
        }
    }
    close(INPUT);

    if(defined $scsi_id) {
        return $scsi_id;
    } else {
        return undef;
    }
}


sub calculate_read_ahead_kb {

    my $block_allocation_type   = shift;
    my $max_sectors_kb          = shift;

    #
    # General best practice: 
    #
    #   If block allocation type is 'scatter', then set to zero.  If
    #   it's 'cluster', then set to /* XXX ask Ray for method to determine this */
    #
    #   -Tuning input from:
    #       Sven Oehme
    #       Ray Paden
    #
    if( "$block_allocation_type" eq 'scatter' ) {
        return 0;
    } else {
        # Hmm.  Must be type 'cluster'
        #XXX Ray -- what formula should we use here?  Using $max_sectors_kb for now... -BEF-
        return $max_sectors_kb;
    }
}


sub calculate_max_sectors_kb {

    my $bs = shift;

    #
    #   GPFS block size / 4 or 512, whichever is greater.
    #
    #   max_sectors_kb should always be set as high as you can,
    #   independent of the blocksize.  However, empirical testing
    #   indicates lower performance, and in rare cases SCSI underruns,
    #   if this is set too high with certain hardware.
    #
    #   Therefore, we start with the conservative setting below, that
    #   should still be an improvement over the out of the box setup.
    #
    #   -Tuning input from:
    #       Sven Oehme
    #       Ray Paden
    #
    my $kb = $bs / 4;

    if( $kb < 512 ) {
        $kb = 512;
    }

    return $kb;
}


sub calculate_nr_requests {

    my $disks_per_array = shift;

    #
    # nr_requests can be higher than queue_depth without much negative
    # impact as the device queue determines how much is actually queued
    # on the device.
    #
    # queue_depth is what can really hurt drive performance if it's set
    # too high.
    #
    # So, 32 per physical disk is a good starting point for nr_requests
    # and a queue depth of 4 per physical disk.
    #
    #   -Tuning input from:
    #       Sven Oehme
    #

    my $nr_requests = $disks_per_array * 32;

    return $nr_requests;
}


sub calculate_queue_depth {

    my $disks_per_array = shift;

    #
    # Let's take an 8+2p array (8 data disks, 2 parity disks, AKA RAID6)
    # as an example:
    #
    #   The most accurate value for _writes_ would be based on 8 disks.
    #   I/O on the other 2 disks is "generated parity" by the array, and
    #   need not be considered by the OS.
    #
    #   The most accurate value for _reads_ would be based on 10 disks.
    #   Reads may pull data from across all 10 disks.
    #
    #   Therefore, we recommend the conservative approach for this tool,
    #   which would be 8.
    #
    #   -Tuning input from:
    #       Sven Oehme
    #

    my $queue_depth = $disks_per_array * 4;

    return $queue_depth;
}


sub version {
    print qq(\n);
    print qq($progname v$version_number\n);
    print qq(\n);
    print qq(    Part of the "gpfs_goodies" package\n);
    print qq(\n);

    return 1;
}

sub usage {
version();
print << "EOF";
Usage:  $progname [OPTION...] --out-file FILE

  WARNING: $progname should be considered BETA code at 
           this point.  It works well in some environments but the
           following tuning settings are currently hard coded pending
           creation of formulas for calculating system specific values.
           If you have such a formula -- let me know. ;-)  -Brian

    All options can be abbreviated to minimum uniqueness.

    This program will examine your environment including GPFS, storage
    servers, disk subsystems, and LUNs, to calculate best practice block
    device tuning settings.  It will create a single udev rules file
    with the tuning settings, using one entry for each LUN, and
    optionally deploy it to each participating storage server.
    
    --help

    --version

    --disks-per-array NN

        Where NN is the number of disks in each array.  
        
        Typically, each LUN presented to the OS represents on RAID array
        in the storage subsystem.  Here are some examples by array type:

            Value for NN    Array Type
            ------------    --------------------------------------------
                 8          8+2p RAID6        (8 data + 2 parity disks)
                 8          8+3p Reed Solomon (8 data + 3 parity disks)
                 4          4+1p RAID5        (4 data + 1 parity disk)

    --test-run

        Create the rules, but don't deploy them.


    --deploy

        Deploy and activate the resultant udev rules file to each
        participating storage server.  Participating storage servers are
        identified by their role as an NSD server for any of the LUNs in
        active file systems.  Execute the command "mmlsnsd" for a list
        of these servers.
        
        The name of the udev rules file on the target NSD servers will
        be: $udev_rules_file


    --out-file FILE

        The name of your resultant udev rules file.  This file can be
        given any name you like.  

        If you also use the --deploy option, this file will be deployed
        to your storage servers with the name of $udev_rules_file.

        Example:  --out-file /tmp/my_shiny_new_udev_rules_file.conf

        Default:  I'll choose one for you and tell you what I've named it.


    Support: 
    
        This software is provided as-is, with no express or implied
        support.  However, the author would love to receive your
        patches.  Please contact Brian E. Finley <bfinley\@us.ibm.com>
        with patches and/or suggestions.

EOF
    return 1;
#XXXX    --file-systems FS1[,FS2,FS3,...]
#
#        A comma delimited list of file systems whose block devices
#        should be tuned.
#        
#        If no --file-systems entry is specified, then block device
#        settings for all file systems
#        will be tuned.
#        
#
}

sub user_is_root {

    if($< == 0) {
        return 1;
    }
    return undef;
}


#
#   END Subroutines
#
########################################################################

#
#   :set tw=0 ts=4 ai et   
#
